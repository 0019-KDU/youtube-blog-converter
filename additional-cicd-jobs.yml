# Add these jobs after cleanup-green-slot and before notify

  # ===========================
  # POST-PRODUCTION VALIDATION
  # ===========================

  production-health-verification:
    name: Production Health Verification
    needs: [cleanup-green-slot]
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Comprehensive Production Health Check
        run: |
          PROD_URL="https://yt-agent-h5hjdchdf0byh7fc.centralus-01.azurewebsites.net"

          echo "üè• Comprehensive Production Health Verification"
          echo "=============================================="

          # 1. Basic HTTP Health Check
          echo "1Ô∏è‚É£ Basic HTTP Health Check..."
          for i in {1..5}; do
            response=$(curl -s -o /dev/null -w "%{http_code}" $PROD_URL/health || echo "000")
            if [ "$response" = "200" ]; then
              echo "‚úÖ Health endpoint responding (attempt $i)"
              break
            else
              echo "‚ö†Ô∏è Health check failed: $response (attempt $i/5)"
              if [ $i -eq 5 ]; then exit 1; fi
              sleep 10
            fi
          done

          # 2. Application-specific endpoints
          echo "2Ô∏è‚É£ Testing Core Application Endpoints..."

          # Test main page
          main_status=$(curl -s -o /dev/null -w "%{http_code}" $PROD_URL/ || echo "000")
          echo "üìÑ Main page: $main_status"

          # Test API endpoints if available
          api_status=$(curl -s -o /dev/null -w "%{http_code}" $PROD_URL/api/health || echo "404")
          echo "üîå API health: $api_status"

          # 3. Performance baseline check
          echo "3Ô∏è‚É£ Performance Baseline Check..."
          response_time=$(curl -o /dev/null -s -w "%{time_total}" $PROD_URL/health)
          echo "‚è±Ô∏è Response time: ${response_time}s"

          # Fail if response time > 5 seconds
          if (( $(echo "$response_time > 5.0" | bc -l) )); then
            echo "‚ùå Production response time too slow: ${response_time}s"
            exit 1
          fi

  mongodb-connectivity-test:
    name: MongoDB Connectivity Test
    needs: [production-health-verification]
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install MongoDB test dependencies
        run: |
          pip install pymongo requests python-dotenv

      - name: Test MongoDB Connection via App
        env:
          PROD_URL: "https://yt-agent-h5hjdchdf0byh7fc.centralus-01.azurewebsites.net"
        run: |
          cat << 'EOF' > test_mongodb.py
          import requests
          import sys
          import os

          def test_mongodb_via_app():
              """Test MongoDB connectivity through the Flask app"""
              base_url = os.environ.get('PROD_URL', 'http://localhost:5000')

              try:
                  # Test if app can connect to MongoDB
                  # This assumes your app has a /api/db-status or similar endpoint
                  response = requests.get(f"{base_url}/health", timeout=30)

                  if response.status_code == 200:
                      print("‚úÖ App is responding - MongoDB likely connected")
                      return True
                  else:
                      print(f"‚ö†Ô∏è App health check returned: {response.status_code}")
                      return False

              except requests.exceptions.RequestException as e:
                  print(f"‚ùå MongoDB connectivity test failed: {e}")
                  return False

          if __name__ == "__main__":
              print("üóÑÔ∏è Testing MongoDB connectivity via production app...")
              success = test_mongodb_via_app()
              sys.exit(0 if success else 1)
          EOF

          python test_mongodb.py

  crewai-functionality-test:
    name: CrewAI Integration Test
    needs: [mongodb-connectivity-test]
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Test CrewAI YouTube Processing
        env:
          PROD_URL: "https://yt-agent-h5hjdchdf0byh7fc.centralus-01.azurewebsites.net"
        run: |
          echo "ü§ñ Testing CrewAI YouTube Blog Conversion Functionality"
          echo "======================================================"

          # Test 1: Check if CrewAI endpoints are available
          echo "1Ô∏è‚É£ Testing CrewAI endpoint availability..."

          # This would test your specific YouTube processing endpoint
          crewai_status=$(curl -s -o /dev/null -w "%{http_code}" \
            -X POST \
            -H "Content-Type: application/json" \
            -d '{"youtube_url": "test", "dry_run": true}' \
            $PROD_URL/api/process-youtube || echo "404")

          echo "üîå CrewAI endpoint status: $crewai_status"

          # Test 2: Check if the app can handle requests (even if they fail due to invalid data)
          # A 400 (bad request) is acceptable - it means the endpoint exists and is processing
          if [[ "$crewai_status" =~ ^(200|400|422)$ ]]; then
            echo "‚úÖ CrewAI endpoint is responding correctly"
          else
            echo "‚ö†Ô∏è CrewAI endpoint may have issues (status: $crewai_status)"
            # Don't fail the pipeline for this - CrewAI might be working but endpoint structure different
          fi

          echo "‚úÖ CrewAI integration test completed"

  production-smoke-tests:
    name: Production Smoke Tests
    needs: [crewai-functionality-test]
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Production Smoke Tests
        env:
          PROD_URL: "https://yt-agent-h5hjdchdf0byh7fc.centralus-01.azurewebsites.net"
        run: |
          echo "üí® Production Smoke Tests"
          echo "========================"

          # Test suite for your Flask + CrewAI + MongoDB app

          echo "1Ô∏è‚É£ Testing static assets loading..."
          css_status=$(curl -s -o /dev/null -w "%{http_code}" $PROD_URL/static/css/style.css || echo "404")
          js_status=$(curl -s -o /dev/null -w "%{http_code}" $PROD_URL/static/js/main.js || echo "404")
          echo "üìÑ CSS: $css_status, JS: $js_status"

          echo "2Ô∏è‚É£ Testing form submissions (if applicable)..."
          # Test your main form endpoint
          form_status=$(curl -s -o /dev/null -w "%{http_code}" \
            -X POST \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "test=true" \
            $PROD_URL/ || echo "405")
          echo "üìù Form handling: $form_status"

          echo "3Ô∏è‚É£ Testing error handling..."
          # Test 404 handling
          error_status=$(curl -s -o /dev/null -w "%{http_code}" $PROD_URL/nonexistent-page || echo "000")
          echo "üö´ 404 handling: $error_status"

          echo "4Ô∏è‚É£ Testing security headers..."
          headers=$(curl -sI $PROD_URL | grep -E "(X-Content-Type-Options|X-Frame-Options|Strict-Transport-Security)")
          if [ -n "$headers" ]; then
            echo "‚úÖ Security headers present:"
            echo "$headers"
          else
            echo "‚ö†Ô∏è Some security headers missing"
          fi

          echo "‚úÖ All smoke tests completed"

  production-metrics-collection:
    name: Collect Production Metrics
    needs: [production-smoke-tests]
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Collect Performance Metrics
        env:
          PROD_URL: "https://yt-agent-h5hjdchdf0byh7fc.centralus-01.azurewebsites.net"
        run: |
          echo "üìä Collecting Production Performance Metrics"
          echo "============================================"

          # Collect baseline metrics for monitoring
          echo "üéØ Testing multiple endpoints for performance baseline..."

          endpoints=("/" "/health")

          for endpoint in "${endpoints[@]}"; do
            echo "Testing: $PROD_URL$endpoint"

            # Collect timing metrics
            metrics=$(curl -o /dev/null -s -w "Response: %{http_code}, Time: %{time_total}s, Size: %{size_download} bytes\n" \
              "$PROD_URL$endpoint" || echo "Failed to collect metrics")

            echo "üìà $endpoint: $metrics"
          done

          echo "‚úÖ Metrics collection completed"

      - name: Store Deployment Success Metrics
        run: |
          echo "üìã Deployment Success Summary"
          echo "============================"
          echo "‚úÖ Deployment completed successfully at: $(date -u)"
          echo "üîó Production URL: $PROD_URL"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üè∑Ô∏è Branch: ${{ github.ref_name }}"
          echo "üî¢ Build: ${{ github.run_number }}"

          # You could also send this to a monitoring system
          # curl -X POST $MONITORING_WEBHOOK -d "deployment_success=true&commit=${{ github.sha }}"