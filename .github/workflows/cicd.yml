name: CI/CD for YouTube Blog Converter

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  issues: write
  contents: read
  pull-requests: write
  checks: write

env:
  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Show commit author
        run: |
          echo "Commit by ${{ github.actor }}"
          echo "Email: ${{ github.event.head_commit.author.email || 'N/A' }}"
          echo "Full details: ${{ toJson(github.event.head_commit.author) }}"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Trivy
        run: |
          sudo apt-get update -y
          sudo apt-get install -y wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update -y
          sudo apt-get install -y trivy

      - name: Filesystem Scan with Trivy
        run: trivy fs --severity HIGH,CRITICAL --exit-code 0 .

      - name: Install Gitleaks
        run: |
          wget https://github.com/gitleaks/gitleaks/releases/download/v8.18.2/gitleaks_8.18.2_linux_x64.tar.gz
          tar -xzf gitleaks_8.18.2_linux_x64.tar.gz
          sudo mv gitleaks /usr/local/bin/
          rm gitleaks_8.18.2_linux_x64.tar.gz

      - name: Secret Detection with Gitleaks
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
            echo "Scanning PR commits against base branch: $BASE_BRANCH"
            git fetch origin "$BASE_BRANCH" --depth=100
            BASE_COMMIT=$(git merge-base "origin/$BASE_BRANCH" HEAD)
            RANGE="$BASE_COMMIT..HEAD"
          elif [ "${{ github.event_name }}" = "push" ]; then
            echo "Scanning push event commits"
            if [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              RANGE="${{ github.event.before }}..${{ github.event.after }}"
            else
              RANGE="${{ github.event.after }}"
            fi
          else
            echo "Unsupported event type: ${{ github.event_name }}"
            exit 1
          fi

          echo "Scanning commit range: $RANGE"
          gitleaks detect \
            --source . \
            --report-format json \
            --report-path gitleaks-report.json \
            --log-opts "$RANGE"

      - name: Create issue on failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const assignee = "${{ github.actor }}";
              const authorName = "${{ github.event.head_commit.author.name }}";
              const authorEmail = "${{ github.event.head_commit.author.email }}";
              
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Security Scan Failure in ${context.job}`,
                body: `### ‚ùå Security Scan Failed\n\n` +
                      `**Job:** ${context.job}\n` +
                      `**Commit:** [${context.sha.substring(0,7)}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/commit/${context.sha})\n` +
                      `**Workflow:** [${context.workflow}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})\n\n` +
                      `**Commit Author:** ${authorName} (${authorEmail})\n\n` +
                      `Please investigate the security scan failure.`,
                assignees: [assignee],
                labels: ['ci-failure', 'security']
              });
            } catch (error) {
              console.error('Error creating issue:', error);
              core.setFailed(`Failed to create issue: ${error.message}`);
            }

      - name: Slack Notification on Failure
        if: ${{ failure() }}
        uses: act10ns/slack@v2.1.0
        with:
          channel: '#githubaction'
          status: ${{ job.status }}
          text: "‚ùå Security Scan Failed in ${{ github.repository }}"
          fields: |
            [
              {"title": "Repository", "value": "${{ github.repository }}", "short": true},
              {"title": "Workflow", "value": "${{ github.workflow }}", "short": true},
              {"title": "Job", "value": "${{ github.job }}", "short": true},
              {"title": "Run ID", "value": "${{ github.run_id }}", "short": true},
              {"title": "Commit", "value": "${{ github.sha }}", "short": true},
              {"title": "Commit Author", "value": "${{ github.event.head_commit.author.name }}", "short": true}
            ]
          footer: "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run>"

  build-and-test:
    runs-on: ubuntu-latest
    # üîß ADD SUPADATA_API_KEY HERE FOR TESTING
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      SUPADATA_API_KEY: ${{ secrets.SUPADATA_API_KEY }}
    steps:
      - name: Show commit author
        run: |
          echo "Commit by ${{ github.actor }}"
          echo "Email: ${{ github.event.head_commit.author.email || 'N/A' }}"
          echo "Full details: ${{ toJson(github.event.head_commit.author) }}"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov
      
      - name: Run tests with coverage
        run: pytest --cov=src --cov-report=xml:coverage.xml -v tests/
        
      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage.xml

      - name: Create issue on failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const assignee = "${{ github.actor }}";
              const authorName = "${{ github.event.head_commit.author.name }}";
              const authorEmail = "${{ github.event.head_commit.author.email }}";
              
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Build/Tests Failed in ${context.job}`,
                body: `### ‚ùå Build/Tests Failed\n\n` +
                      `**Job:** ${context.job}\n` +
                      `**Commit:** [${context.sha.substring(0,7)}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/commit/${context.sha})\n` +
                      `**Workflow:** [${context.workflow}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})\n\n` +
                      `**Commit Author:** ${authorName} (${authorEmail})\n\n` +
                      `Test failures detected. Please check the build logs.`,
                assignees: [assignee],
                labels: ['ci-failure', 'tests']
              });
            } catch (error) {
              console.error('Error creating issue:', error);
              core.setFailed(`Failed to create issue: ${error.message}`);
            }

      - name: Slack Notification on Failure
        if: ${{ failure() }}
        uses: act10ns/slack@v2.1.0
        with:
          channel: '#githubaction'
          status: ${{ job.status }}
          text: "‚ùå Build/Tests Failed in ${{ github.repository }}"
          fields: |
            [
              {"title": "Repository", "value": "${{ github.repository }}", "short": true},
              {"title": "Workflow", "value": "${{ github.workflow }}", "short": true},
              {"title": "Job", "value": "${{ github.job }}", "short": true},
              {"title": "Run ID", "value": "${{ github.run_id }}", "short": true},
              {"title": "Commit", "value": "${{ github.sha }}", "short": true},
              {"title": "Commit Author", "value": "${{ github.event.head_commit.author.name }}", "short": true}
            ]
          footer: "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run>"

  sonarqube-scan:
    runs-on: self-hosted
    needs: build-and-test
    steps:
      - name: Show commit author
        run: |
          echo "Commit by ${{ github.actor }}"
          echo "Email: ${{ github.event.head_commit.author.email || 'N/A' }}"
          echo "Full details: ${{ toJson(github.event.head_commit.author) }}"
          
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Download coverage report
        uses: actions/download-artifact@v4
        with:
          name: coverage-report
          path: .
          
      - name: SonarQube Scan
        id: sonar-scan
        uses: SonarSource/sonarqube-scan-action@v5.2.0
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ vars.SONAR_HOST_URL }}
        with:
          args: >
            -Dsonar.python.coverage.reportPaths=coverage.xml
            -Dsonar.python.version=3.12
            -Dsonar.sources=src
            -Dsonar.tests=tests
            -Dsonar.test.inclusions=tests/**
            -Dsonar.exclusions=**/__pycache__/**,**/.pytest_cache/**,**/env/**
            -Dsonar.projectKey=${{ vars.SONAR_PROJECT_KEY }}
            -Dsonar.projectName=${{ vars.SONAR_PROJECT_NAME }}
            -Dsonar.projectVersion=1.0.${{ github.run_number }}
            -Dsonar.qualitygate.wait=true
            -Dsonar.scm.provider=git
            -Dsonar.links.scm=${{ github.server_url }}/${{ github.repository }}
            -Dsonar.links.ci=${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            
      - name: SonarQube Quality Gate check
        id: sonar-quality-gate
        uses: sonarsource/sonarqube-quality-gate-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ vars.SONAR_HOST_URL }}

      - name: Create Detailed SonarQube PR Comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const sonarUrl = '${{ vars.SONAR_HOST_URL }}';
            const projectKey = '${{ vars.SONAR_PROJECT_KEY }}';
            const token = '${{ secrets.SONAR_TOKEN }}';
            
            try {
              // Create Basic Auth header - SonarQube uses token as username with empty password
              const auth = Buffer.from(`${token}:`).toString('base64');
              
              // Get project measures from SonarQube API
              const metricsResponse = await fetch(
                `${sonarUrl}/api/measures/component?component=${projectKey}&metricKeys=bugs,vulnerabilities,security_hotspots,code_smells,coverage,duplicated_lines_density,ncloc,sqale_rating,reliability_rating,security_rating`,
                {
                  headers: {
                    'Authorization': `Basic ${auth}`,
                    'Content-Type': 'application/json'
                  }
                }
              );
              
              if (!metricsResponse.ok) {
                const errorText = await metricsResponse.text();
                throw new Error(`SonarQube API error: ${metricsResponse.status} - ${errorText}`);
              }
              
              const metricsData = await metricsResponse.json();
              const measures = metricsData.component.measures;
              
              // Get Quality Gate status
              const qualityGateResponse = await fetch(
                `${sonarUrl}/api/qualitygates/project_status?projectKey=${projectKey}`,
                {
                  headers: {
                    'Authorization': `Basic ${auth}`,
                    'Content-Type': 'application/json'
                  }
                }
              );
              
              if (!qualityGateResponse.ok) {
                const errorText = await qualityGateResponse.text();
                throw new Error(`SonarQube Quality Gate API error: ${qualityGateResponse.status} - ${errorText}`);
              }
              
              const qualityGateData = await qualityGateResponse.json();
              const qualityGateStatus = qualityGateData.projectStatus.status;
              
              // Helper function to get metric value
              function getMetricValue(metricKey) {
                const measure = measures.find(m => m.metric === metricKey);
                return measure ? measure.value : 'N/A';
              }
              
              // Helper function to get rating emoji
              function getRatingEmoji(rating) {
                switch(rating) {
                  case 'A': return 'üü¢';
                  case 'B': return 'üü°';
                  case 'C': return 'üü†';
                  case 'D': return 'üî¥';
                  case 'E': return 'üî¥';
                  default: return '‚ö™';
                }
              }
              
              // Create detailed comment body using string concatenation
              const statusSection = qualityGateStatus === 'OK' ? '‚úÖ **PASSED**' : '‚ùå **FAILED**';
              
              const metricsTable = [
                '| Metric | Value | Rating |',
                '|--------|-------|--------|',
                `| üêõ **Bugs** | ${getMetricValue('bugs')} | ${getRatingEmoji(getMetricValue('reliability_rating'))} |`,
                `| üîí **Vulnerabilities** | ${getMetricValue('vulnerabilities')} | ${getRatingEmoji(getMetricValue('security_rating'))} |`,
                `| üî• **Security Hotspots** | ${getMetricValue('security_hotspots')} | - |`,
                `| üí® **Code Smells** | ${getMetricValue('code_smells')} | ${getRatingEmoji(getMetricValue('sqale_rating'))} |`,
                `| üìè **Lines of Code** | ${getMetricValue('ncloc')} | - |`,
                `| üß™ **Coverage** | ${getMetricValue('coverage')}% | - |`,
                `| üìã **Duplicated Lines** | ${getMetricValue('duplicated_lines_density')}% | - |`
              ].join('\n');
              
              const linksSection = [
                '### üîó Links',
                `- [üìä View Full Report](${sonarUrl}/dashboard?id=${projectKey})`,
                `- [üîç View Issues](${sonarUrl}/project/issues?resolved=false&id=${projectKey})`,
                `- [üìà View Measures](${sonarUrl}/component_measures?id=${projectKey})`
              ].join('\n');
              
              const detailsSection = [
                '### ‚ÑπÔ∏è Analysis Details',
                `- **Project Key**: \`${projectKey}\``,
                `- **Analysis Date**: ${new Date().toISOString()}`,
                `- **Commit**: \`${context.sha.substring(0, 7)}\``,
                `- **Workflow Run**: [#${context.runNumber}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`
              ].join('\n');
              
              const commentBody = [
                '## üìä SonarQube Analysis Results',
                '',
                '### Quality Gate Status',
                statusSection,
                '',
                '### üìà Code Quality Metrics',
                '',
                metricsTable,
                '',
                linksSection,
                '',
                detailsSection,
                '',
                '---',
                '*This comment was automatically generated by SonarQube analysis in GitHub Actions*'
              ].join('\n');
              
              // Post comment to PR
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commentBody
              });
              
              console.log('Successfully posted SonarQube analysis results to PR');
              
            } catch (error) {
              console.error('Error creating SonarQube PR comment:', error);
              core.setFailed(`Failed to create PR comment: ${error.message}`);
            }

      - name: Create issue on failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const assignee = "${{ github.actor }}";
              const authorName = "${{ github.event.head_commit.author.name }}";
              const authorEmail = "${{ github.event.head_commit.author.email }}";
              
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `SonarQube Failure in ${context.job}`,
                body: `### ‚ùå SonarQube Quality Gate Failed\n\n` +
                      `**Job:** ${context.job}\n` +
                      `**Commit:** [${context.sha.substring(0,7)}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/commit/${context.sha})\n` +
                      `**Workflow:** [${context.workflow}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})\n\n` +
                      `**Commit Author:** ${authorName} (${authorEmail})\n\n` +
                      `Quality gate check failed. Please review SonarQube analysis.`,
                assignees: [assignee],
                labels: ['ci-failure', 'quality']
              });
            } catch (error) {
              console.error('Error creating issue:', error);
              core.setFailed(`Failed to create issue: ${error.message}`);
            }

      - name: Slack Notification on Failure
        if: ${{ failure() }}
        uses: act10ns/slack@v2.1.0
        with:
          channel: '#githubaction'
          status: ${{ job.status }}
          text: "‚ùå SonarQube Scan Failed in ${{ github.repository }}"
          fields: |
            [
              {"title": "Repository", "value": "${{ github.repository }}", "short": true},
              {"title": "Workflow", "value": "${{ github.workflow }}", "short": true},
              {"title": "Job", "value": "${{ github.job }}", "short": true},
              {"title": "Run ID", "value": "${{ github.run_id }}", "short": true},
              {"title": "Commit", "value": "${{ github.sha }}", "short": true},
              {"title": "Commit Author", "value": "${{ github.event.head_commit.author.name }}", "short": true}
            ]
          footer: "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run>"

  docker-build-test:
    needs: [security-scan, build-and-test, sonarqube-scan]
    runs-on: ubuntu-latest
    steps:
      - name: Show commit author
        run: |
          echo "Commit by ${{ github.actor }}"
          echo "Email: ${{ github.event.head_commit.author.email || 'N/A' }}"
          echo "Full details: ${{ toJson(github.event.head_commit.author) }}"
        
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Install Trivy (for container scanning)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update -y
          sudo apt-get install -y trivy

      - name: Build Docker image
        run: docker build -t youtube-blog-converter:${{ github.sha }} .

      - name: Container Vulnerability Scan with Trivy
        run: trivy image --severity HIGH,CRITICAL --exit-code 0 youtube-blog-converter:${{ github.sha }}
      
      # üîß ADD BOTH API KEYS TO SMOKE TEST
      - name: Run smoke test
        run: |
          docker run -d --name smoke-test \
            -e OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
            -e SUPADATA_API_KEY="${{ secrets.SUPADATA_API_KEY }}" \
            -e JWT_SECRET_KEY="${{ secrets.JWT_SECRET_KEY }}" \
            -e JWT_ACCESS_TOKEN_EXPIRES="${{ secrets.JWT_ACCESS_TOKEN_EXPIRES }}" \
            -e MONGODB_URI="${{ secrets.MONGODB_URI }}" \
            -e MONGODB_DB_NAME="${{ secrets.MONGODB_DB_NAME }}" \
            -e FLASK_SECRET_KEY="${{ secrets.FLASK_SECRET_KEY }}" \
            -e FLASK_DEBUG="false" \
            -e FLASK_HOST="0.0.0.0" \
            -e OPENAI_MODEL_NAME="${{ secrets.OPENAI_MODEL_NAME }}" \
            -p 5000:5000 \
            youtube-blog-converter:${{ github.sha }}
          # wait for Flask to boot
          for i in {1..10}; do
            docker logs smoke-test 2>&1 | grep -q "Running on" && break
            sleep 2
          done
          docker logs smoke-test
          curl --retry 5 --retry-delay 5 --retry-connrefused http://localhost:5000/
          docker stop smoke-test


      - name: Create issue on failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const assignee = "${{ github.actor }}";
              const authorName = "${{ github.event.head_commit.author.name }}";
              const authorEmail = "${{ github.event.head_commit.author.email }}";
              
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Docker Build Failed in ${context.job}`,
                body: `### ‚ùå Docker Build/Test Failed\n\n` +
                      `**Job:** ${context.job}\n` +
                      `**Commit:** [${context.sha.substring(0,7)}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/commit/${context.sha})\n` +
                      `**Workflow:** [${context.workflow}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})\n\n` +
                      `**Commit Author:** ${authorName} (${authorEmail})\n\n` +
                      `Docker build or smoke test failed. Please check container logs.`,
                assignees: [assignee],
                labels: ['ci-failure', 'docker']
              });
            } catch (error) {
              console.error('Error creating issue:', error);
              core.setFailed(`Failed to create issue: ${error.message}`);
            }

      - name: Slack Notification on Failure
        if: ${{ failure() }}
        uses: act10ns/slack@v2.1.0
        with:
          channel: '#githubaction'
          status: ${{ job.status }}
          text: "‚ùå Docker Build Failed in ${{ github.repository }}"
          fields: |
            [
              {"title": "Repository", "value": "${{ github.repository }}", "short": true},
              {"title": "Workflow", "value": "${{ github.workflow }}", "short": true},
              {"title": "Job", "value": "${{ github.job }}", "short": true},
              {"title": "Run ID", "value": "${{ github.run_id }}", "short": true},
              {"title": "Commit", "value": "${{ github.sha }}", "short": true},
              {"title": "Commit Author", "value": "${{ github.event.head_commit.author.name }}", "short": true}
            ]
          footer: "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run>"

  deploy-to-dockerhub:
    needs: docker-build-test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - name: Show commit author
        run: |
          echo "Commit by ${{ github.actor }}"
          echo "Email: ${{ github.event.head_commit.author.email || 'N/A' }}"
          echo "Full details: ${{ toJson(github.event.head_commit.author) }}"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/youtube-blog-converter:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/youtube-blog-converter:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify deployment
        run: |
          echo "Successfully deployed to Docker Hub!"
          echo "Image: ${{ secrets.DOCKERHUB_USERNAME }}/youtube-blog-converter:${{ github.sha }}"

      - name: Create issue on failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const assignee = "${{ github.actor }}";
              const authorName = "${{ github.event.head_commit.author.name }}";
              const authorEmail = "${{ github.event.head_commit.author.email }}";
              
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Deployment Failed in ${context.job}`,
                body: `### ‚ùå Deployment to Docker Hub Failed\n\n` +
                      `**Job:** ${context.job}\n` +
                      `**Commit:** [${context.sha.substring(0,7)}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/commit/${context.sha})\n` +
                      `**Workflow:** [${context.workflow}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})\n\n` +
                      `**Commit Author:** ${authorName} (${authorEmail})\n\n` +
                      `Deployment to Docker Hub failed. Please check build logs.`,
                assignees: [assignee],
                labels: ['ci-failure', 'deployment']
              });
            } catch (error) {
              console.error('Error creating issue:', error);
              core.setFailed(`Failed to create issue: ${error.message}`);
            }

      - name: Slack Notification on Failure
        if: ${{ failure() }}
        uses: act10ns/slack@v2.1.0
        with:
          channel: '#githubaction'
          status: ${{ job.status }}
          text: "‚ùå Deployment Failed in ${{ github.repository }}"
          fields: |
            [
              {"title": "Repository", "value": "${{ github.repository }}", "short": true},
              {"title": "Workflow", "value": "${{ github.workflow }}", "short": true},
              {"title": "Job", "value": "${{ github.job }}", "short": true},
              {"title": "Run ID", "value": "${{ github.run_id }}", "short": true},
              {"title": "Commit", "value": "${{ github.sha }}", "short": true},
              {"title": "Commit Author", "value": "${{ github.event.head_commit.author.name }}", "short": true}
            ]
          footer: "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run>"

  deploy-to-azure:
    needs: deploy-to-dockerhub
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Clear Container App Cache and Reset
        run: |
          echo "üßπ Clearing existing cache and resetting container app..."
          
          # Stop all traffic to current revision
          echo "Stopping traffic to current revision..."
          az containerapp revision set-mode \
            --name ${{ secrets.CONTAINER_APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --mode Single || echo "Mode setting skipped"
          
          # Deactivate old revisions to force cache clear
          echo "Deactivating old revisions..."
          REVISIONS=$(az containerapp revision list \
            --name ${{ secrets.CONTAINER_APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --query "[?properties.active].name" -o tsv)
          
          for revision in $REVISIONS; do
            echo "Deactivating revision: $revision"
            az containerapp revision deactivate \
              --name ${{ secrets.CONTAINER_APP_NAME }} \
              --resource-group ${{ secrets.RESOURCE_GROUP }} \
              --revision "$revision" || echo "Failed to deactivate $revision"
          done

      - name: Force Remove Existing Registry Config
        run: |
          echo "üîÑ Removing existing registry configuration..."
          az containerapp registry remove \
            --name ${{ secrets.CONTAINER_APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --server docker.io || echo "Registry not present"

      - name: Configure Docker Hub Registry
        run: |
          echo "üìù Configuring Docker Hub registry..."
          az containerapp registry set \
            --name ${{ secrets.CONTAINER_APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --server docker.io \
            --username ${{ secrets.DOCKERHUB_USERNAME }} \
            --password ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Force Image Pull and Deploy
        run: |
          echo "üöÄ Forcing new image pull and deployment..."
          REVISION_SUFFIX="rev-$(date +%s)-${{ github.run_number }}"
          
          # Use --force-restart to ensure fresh deployment
          az containerapp update \
            --name ${{ secrets.CONTAINER_APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --image ${{ secrets.DOCKERHUB_USERNAME }}/youtube-blog-converter:${{ github.sha }} \
            --revision-suffix "$REVISION_SUFFIX" \
            --set-env-vars "CACHE_BUST=$(date +%s)" "DEPLOYMENT_ID=${{ github.run_id }}"
          
          echo "‚úÖ Deployed with revision suffix: $REVISION_SUFFIX"

      - name: Wait for Old Revisions to Terminate
        run: |
          echo "‚è≥ Waiting for old revisions to terminate..."
          sleep 30
          
          # Check if old revisions are properly terminated
          ACTIVE_REVISIONS=$(az containerapp revision list \
            --name ${{ secrets.CONTAINER_APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --query "[?properties.active].name" -o tsv | wc -l)
          
          echo "Active revisions count: $ACTIVE_REVISIONS"

      - name: Verify Image and Clear Container Cache
        run: |
          echo "üîç Verifying deployed image and clearing container cache..."
          sleep 15
          
          # Force container restart to clear any internal cache
          az containerapp restart \
            --name ${{ secrets.CONTAINER_APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} || echo "Restart command completed"
          
          # Wait for restart to complete
          sleep 20
          
          # Verify the correct image is deployed
          CURRENT_IMAGE=$(az containerapp show \
            --name ${{ secrets.CONTAINER_APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --query "properties.template.containers[0].image" -o tsv)
          
          EXPECTED_IMAGE="${{ secrets.DOCKERHUB_USERNAME }}/youtube-blog-converter:${{ github.sha }}"
          
          echo "Current deployed image: $CURRENT_IMAGE"
          echo "Expected image: $EXPECTED_IMAGE"
          
          if [ "$CURRENT_IMAGE" != "$EXPECTED_IMAGE" ]; then
            echo "::error::Image verification failed!"
            echo "::error::Current: $CURRENT_IMAGE"
            echo "::error::Expected: $EXPECTED_IMAGE"
            exit 1
          else
            echo "‚úÖ Image verification successful!"
          fi

      - name: Force Application Cache Clear
        run: |
          echo "üßπ Forcing application-level cache clear..."
          
          # Get the application URL first
          URL=$(az containerapp show \
            --name ${{ secrets.CONTAINER_APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --query "properties.configuration.ingress.fqdn" \
            --output tsv)
          
          # Wait for service to be ready
          sleep 30
          
          # Multiple cache-busting requests
          for i in {1..3}; do
            echo "Cache-busting request $i..."
            curl -s -H "Cache-Control: no-cache" \
                -H "Pragma: no-cache" \
                -H "X-Cache-Bust: $(date +%s)" \
                "https://$URL/?cachebust=$(date +%s)" > /dev/null || echo "Request $i failed"
            sleep 5
          done

      - name: Get Container App URL
        id: get-url
        run: |
          echo "üîç Retrieving final app URL..."
          URL=$(az containerapp show \
            --name ${{ secrets.CONTAINER_APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --query "properties.configuration.ingress.fqdn" \
            --output tsv)
          echo "Container App URL: https://$URL"
          echo "url=https://$URL" >> $GITHUB_OUTPUT

      - name: Comprehensive Health Check
        run: |
          echo "ü©∫ Running comprehensive health checks..."
          APP_URL="${{ steps.get-url.outputs.url }}"
          
          # Wait for full deployment stabilization
          sleep 45
          
          # Health check with cache-busting headers
          echo "Testing application health with cache-busting..."
          HEALTH_CHECK_PASSED=false
          
          for attempt in {1..8}; do
            echo "Health check attempt $attempt/8..."
            
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
              -H "Cache-Control: no-cache, no-store, must-revalidate" \
              -H "Pragma: no-cache" \
              -H "Expires: 0" \
              -H "X-Cache-Bust: $(date +%s)" \
              "$APP_URL/?v=$(date +%s)" || echo "000")
            
            echo "HTTP response code: $HTTP_CODE"
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Health check passed on attempt $attempt"
              HEALTH_CHECK_PASSED=true
              break
            else
              echo "‚ö†Ô∏è Health check failed with code $HTTP_CODE, retrying..."
              sleep 20
            fi
          done
          
          if [ "$HEALTH_CHECK_PASSED" = "false" ]; then
            echo "‚ùå Health check failed after all attempts"
            
            # Debug information
            echo "=== DEBUG INFORMATION ==="
            echo "App URL: $APP_URL"
            echo "Checking container logs..."
            az containerapp logs show \
              --name ${{ secrets.CONTAINER_APP_NAME }} \
              --resource-group ${{ secrets.RESOURCE_GROUP }} \
              --tail 50 || echo "Failed to retrieve logs"
            
            exit 1
          fi

      - name: Verify Deployment Completion
        run: |
          echo "üîç Final deployment verification..."
          
          # Check latest revision status
          LATEST_REVISION=$(az containerapp revision list \
            --name ${{ secrets.CONTAINER_APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --query "[0]" -o json)
          
          REVISION_STATE=$(echo "$LATEST_REVISION" | jq -r '.properties.provisioningState')
          REVISION_ACTIVE=$(echo "$LATEST_REVISION" | jq -r '.properties.active')
          REVISION_NAME=$(echo "$LATEST_REVISION" | jq -r '.name')
          
          echo "Latest revision: $REVISION_NAME"
          echo "Revision state: $REVISION_STATE"
          echo "Revision active: $REVISION_ACTIVE"
          
          if [ "$REVISION_STATE" = "Succeeded" ] && [ "$REVISION_ACTIVE" = "true" ]; then
            echo "‚úÖ Deployment verification successful!"
          else
            echo "‚ö†Ô∏è Deployment may not be fully complete"
            echo "State: $REVISION_STATE, Active: $REVISION_ACTIVE"
          fi

      - name: Cache Clear Verification
        run: |
          echo "üîç Verifying cache has been cleared..."
          APP_URL="${{ steps.get-url.outputs.url }}"
          
          # Test with different cache-busting parameters
          for i in {1..3}; do
            RESPONSE=$(curl -s -H "Cache-Control: no-cache" \
                            -H "X-Deployment-Version: ${{ github.sha }}" \
                            "$APP_URL/?test=$i&timestamp=$(date +%s)" || echo "FAILED")
            
            if echo "$RESPONSE" | grep -q "title\|html\|DOCTYPE" 2>/dev/null; then
              echo "‚úÖ Cache clear verification $i: SUCCESS"
            else
              echo "‚ö†Ô∏è Cache clear verification $i: UNCLEAR"
            fi
            sleep 2
          done

      - name: Verify Azure deployment
        run: |
          echo "‚úÖ Successfully deployed to Azure Container Apps!"
          echo "Image: ${{ secrets.DOCKERHUB_USERNAME }}/youtube-blog-converter:${{ github.sha }}"
          echo "Application URL: ${{ steps.get-url.outputs.url }}"
          echo "Deployment ID: ${{ github.run_id }}"
          echo "Cache cleared and new version verified!"

      - name: Create issue on failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const assignee = "${{ github.actor }}";
              const authorName = "${{ github.event.head_commit.author.name }}";
              const authorEmail = "${{ github.event.head_commit.author.email }}";
              
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Azure Deployment Failed in ${context.job}`,
                body: `### ‚ùå Deployment to Azure Container Apps Failed\n\n` +
                      `**Job:** ${context.job}\n` +
                      `**Commit:** [${context.sha.substring(0,7)}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/commit/${context.sha})\n` +
                      `**Workflow:** [${context.workflow}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})\n\n` +
                      `**Commit Author:** ${authorName} (${authorEmail})\n\n` +
                      `Deployment to Azure Container Apps failed after cache clearing attempts.\n\n` +
                      `**Expected Image:** ${{ secrets.DOCKERHUB_USERNAME }}/youtube-blog-converter:${{ github.sha }}\n` +
                      `**App URL:** ${{ steps.get-url.outputs.url || 'URL not available' }}\n` +
                      `**Deployment ID:** ${{ github.run_id }}\n\n` +
                      `Please check deployment logs and Azure Portal for detailed error information.`,
                assignees: [assignee],
                labels: ['ci-failure', 'azure-deployment', 'cache-issue']
              });
            } catch (error) {
              console.error('Error creating issue:', error);
              core.setFailed(`Failed to create issue: ${error.message}`);
            }

      - name: Slack Notification on Failure
        if: ${{ failure() }}
        uses: act10ns/slack@v2.1.0
        with:
          channel: '#githubaction'
          status: ${{ job.status }}
          text: "‚ùå Azure Deployment Failed in ${{ github.repository }}"
          fields: |
            [
              {"title": "Repository", "value": "${{ github.repository }}", "short": true},
              {"title": "Workflow", "value": "${{ github.workflow }}", "short": true},
              {"title": "Job", "value": "${{ github.job }}", "short": true},
              {"title": "Run ID", "value": "${{ github.run_id }}", "short": true},
              {"title": "Commit", "value": "${{ github.sha }}", "short": true},
              {"title": "Commit Author", "value": "${{ github.event.head_commit.author.name }}", "short": true}
            ]
          footer: "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run>"

      - name: Slack Notification on Success
        if: ${{ success() }}
        uses: act10ns/slack@v2.1.0
        with:
          channel: '#githubaction'
          status: 'success'
          text: "‚úÖ Azure Deployment Successful with Cache Clear in ${{ github.repository }}"
          fields: |
            [
              {"title": "Repository", "value": "${{ github.repository }}", "short": true},
              {"title": "Image", "value": "${{ secrets.DOCKERHUB_USERNAME }}/youtube-blog-converter:${{ github.sha }}", "short": true},
              {"title": "Application URL", "value": "${{ steps.get-url.outputs.url }}", "short": false},
              {"title": "Run ID", "value": "${{ github.run_id }}", "short": true},
              {"title": "Commit", "value": "${{ github.sha }}", "short": true},
              {"title": "Cache Status", "value": "Cleared and Verified", "short": true}
            ]
          footer: "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run>"


  notify:
    name: Pipeline Status Notification
    if: always()
    runs-on: ubuntu-latest
    needs: 
      - security-scan
      - build-and-test
      - sonarqube-scan
      - docker-build-test
      - deploy-to-dockerhub
      - deploy-to-azure
    steps:
      - name: Aggregate job statuses
        id: status
        run: |
          failed_jobs=""
          successful_jobs=""
          skipped_jobs=""

          if [[ "${{ needs.security-scan.result }}" == 'failure' ]]; then 
            failed_jobs+="Security Scan, "
          elif [[ "${{ needs.security-scan.result }}" == 'success' ]]; then
            successful_jobs+="Security Scan, "
          else
            skipped_jobs+="Security Scan, "
          fi

          if [[ "${{ needs.build-and-test.result }}" == 'failure' ]]; then 
            failed_jobs+="Build and Test, "
          elif [[ "${{ needs.build-and-test.result }}" == 'success' ]]; then
            successful_jobs+="Build and Test, "
          else
            skipped_jobs+="Build and Test, "
          fi

          if [[ "${{ needs.sonarqube-scan.result }}" == 'failure' ]]; then 
            failed_jobs+="SonarQube Scan, "
          elif [[ "${{ needs.sonarqube-scan.result }}" == 'success' ]]; then
            successful_jobs+="SonarQube Scan, "
          else
            skipped_jobs+="SonarQube Scan, "
          fi

          if [[ "${{ needs.docker-build-test.result }}" == 'failure' ]]; then 
            failed_jobs+="Docker Build, "
          elif [[ "${{ needs.docker-build-test.result }}" == 'success' ]]; then
            successful_jobs+="Docker Build, "
          else
            skipped_jobs+="Docker Build, "
          fi

          if [[ "${{ needs.deploy-to-dockerhub.result }}" == 'failure' ]]; then 
            failed_jobs+="Docker Hub Deployment, "
          elif [[ "${{ needs.deploy-to-dockerhub.result }}" == 'success' ]]; then
            successful_jobs+="Docker Hub Deployment, "
          else
            skipped_jobs+="Docker Hub Deployment, "
          fi

          if [[ "${{ needs.deploy-to-azure.result }}" == 'failure' ]]; then 
            failed_jobs+="Azure Deployment, "
          elif [[ "${{ needs.deploy-to-azure.result }}" == 'success' ]]; then
            successful_jobs+="Azure Deployment, "
          else
            skipped_jobs+="Azure Deployment, "
          fi

          failed_jobs=${failed_jobs%, }
          successful_jobs=${successful_jobs%, }
          skipped_jobs=${skipped_jobs%, }

          echo "failed_jobs=$failed_jobs" >> $GITHUB_OUTPUT
          echo "successful_jobs=$successful_jobs" >> $GITHUB_OUTPUT
          echo "skipped_jobs=$skipped_jobs" >> $GITHUB_OUTPUT
          
          if [ -n "$failed_jobs" ]; then
            echo "overall_status=failure" >> $GITHUB_OUTPUT
          elif [ -n "$successful_jobs" ]; then
            echo "overall_status=success" >> $GITHUB_OUTPUT
          else
            echo "overall_status=skipped" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        uses: act10ns/slack@v2.1.0
        with:
          channel: '#githubaction'
          status: ${{ job.status }}
          icon_emoji: ${{ steps.status.outputs.overall_status == 'success' && ':white_check_mark:' || ':x:' }}
          text: |
            ${{ steps.status.outputs.overall_status == 'success' && '‚úÖ Complete Pipeline Succeeded!' || '‚ùå Pipeline Failed!' }}
            ${{ steps.status.outputs.overall_status == 'skipped' && '‚ö†Ô∏è Pipeline Skipped!' }}
          fields: |
            [
              {"title": "Repository", "value": "${{ github.repository }}", "short": true},
              {"title": "Workflow", "value": "${{ github.workflow }}", "short": true},
              {"title": "Run ID", "value": "${{ github.run_id }}", "short": true},
              {"title": "Commit", "value": "${{ github.sha }}", "short": true},
              {"title": "Triggered by", "value": "${{ github.actor }}", "short": true},
              ${{ steps.status.outputs.successful_jobs != '' && format('{{"title": "Successful Jobs", "value": "{0}", "short": true}},', steps.status.outputs.successful_jobs) || '' }}
              ${{ steps.status.outputs.failed_jobs != '' && format('{{"title": "Failed Jobs", "value": "{0}", "short": true}},', steps.status.outputs.failed_jobs) || '' }}
              ${{ steps.status.outputs.skipped_jobs != '' && format('{{"title": "Skipped Jobs", "value": "{0}", "short": true}}', steps.status.outputs.skipped_jobs) || '' }}
            ]
          footer: "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run Details>"
